# Проблема с отображением лоадера при загрузке модулей

## Описание проблемы
При переходе на роут, который требует загрузки нового модуля:
1. После клика на ссылку UI полностью блокируется
2. Начинается загрузка модуля (2-3 секунды)
3. Лоадер показывается только ПОСЛЕ загрузки модуля на мгновение
4. Затем происходит переход на новый роут

**Ожидаемое поведение:** Лоадер должен показываться СРАЗУ после клика, до начала загрузки модулей.

## Технические детали

### Архитектура загрузки модулей
- **Файл:** `globals.app.js:89-119`
- Модули загружаются динамически в `router.beforeEach` guard
- Модули регистрируют роуты через `router.addRoute()` после загрузки
- После загрузки возвращается `to.fullPath` для повторной навигации

### Условие показа лоадера
- **Файл:** `Client.vue:16`
- Условие: `v-if="!page || globals.state.loading"`
- `page` - ref на текущий компонент страницы
- `globals.state.loading` - глобальный флаг загрузки

## Корень проблемы
Vue Router `beforeEach` guard блокирует все обновления DOM до своего завершения:
- Guards выполняются синхронно и блокируют навигацию
- Vue не может обновить DOM пока `beforeEach` не завершится
- Даже установка `globals.state.loading = true` не приводит к рендерингу

**Подтверждение из документации Vue Router:**
> "Guards may be resolved asynchronously, and the navigation is considered pending before all hooks have been resolved"

**GitHub issue vuejs/vue #9200:**
> "Vue.nextTick doesn't seem to cover browser re-render"

## Что пробовали и не сработало

### 1. nextTick после установки loading флага
```javascript
store.globals.state.loading = true;
await nextTick();
```
**Результат:** Не работает, т.к. nextTick работает с микротасками, которые выполняются ДО отрисовки браузером

### 2. requestAnimationFrame
```javascript
store.globals.state.loading = true;
await new Promise(resolve => requestAnimationFrame(resolve));
```
**Результат:** Не работает, beforeEach все равно блокирует рендеринг

### 3. setTimeout с return false
```javascript
setTimeout(async () => {
  // загрузка модулей
  router.push(to.fullPath);
}, 0);
return false;
```
**Результат:** Приводит к 404, т.к. роуты еще не зарегистрированы

### 4. Watch на route.path в Client.vue
```javascript
watch(() => route.path, () => {
  page.value = null;
});
```
**Результат:** Не работает, т.к. route.path меняется только ПОСЛЕ завершения beforeEach

### 5. Свой beforeEach в Client.vue
```javascript
router.beforeEach((to, from) => {
  page.value = null;
});
```
**Результат:** Не работает, все beforeEach выполняются синхронно и блокируют рендеринг

### 6. Создание DOM элемента напрямую
```javascript
const loader = document.createElement('div');
document.body.appendChild(loader);
```
**Результат:** Работает, но это хак, обходящий Vue реактивность

## Ограничения
1. **Нельзя загружать модули после навигации** - модули регистрируют роуты, без них будет 404
2. **Нельзя загружать модули вне beforeEach** - нужно гарантировать загрузку ДО навигации
3. **return to.fullPath необходим** - для повторной навигации с новыми роутами

## Возможные решения

### 1. Использовать HTML лоадер (не Vue компонент)
Добавить лоадер прямо в index.html, показывать/скрывать через классы

### 2. Изменить архитектуру загрузки
- Предзагружать все возможные роуты
- Использовать другой подход к динамической регистрации

### 3. Использовать Web Workers
Загружать модули в воркере, но это потребует полного рефакторинга

## Вывод
Проблема фундаментальная: Vue Router beforeEach блокирует рендеринг, а мы обязаны загружать модули именно там из-за динамической регистрации роутов. Единственное рабочее решение - создавать лоадер в обход Vue (прямой DOM манипуляцией).